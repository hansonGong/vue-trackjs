(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['vue-track'] = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    class LocalStorage {
        static set(sName, value) {
            if (!sName)
                return;
            if (typeof value !== 'string') {
                value = JSON.stringify(value);
            }
            window.localStorage.setItem(sName, value);
        }
        static get(sName) {
            let info = window.localStorage.getItem(sName) || '';
            try {
                info = JSON.parse(info);
            }
            finally {
                return info;
            }
        }
        static remove(sName) {
            if (!sName)
                return;
            window.localStorage.removeItem(sName);
        }
    }

    /**
     * 获取设备操作系统
     */
    function getOS() {
        const userAgent = window.navigator.userAgent;
        const platform = window.navigator.platform;
        const macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
        const windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
        const iosPlatforms = ['iPhone', 'iPad', 'iPod'];
        let os = '';
        if (~macosPlatforms.indexOf(platform)) {
            os = 'Mac OS';
        }
        else if (~iosPlatforms.indexOf(platform)) {
            os = 'iOS';
        }
        else if (~windowsPlatforms.indexOf(platform)) {
            os = 'Windows';
        }
        else if (/Android/.test(userAgent)) {
            os = 'Android';
        }
        else if (!os && /Linux/.test(platform)) {
            os = 'Linux';
        }
        return os;
    }
    /**
     * 获取浏览器信息
     */
    function getBrowserInfo() {
        const agent = navigator.userAgent.toLowerCase();
        let regArray;
        if (agent.indexOf('msie') > 0) {
            const regStr_ie = /msie [\d.]+;/gi;
            regArray = agent.match(regStr_ie);
        }
        else if (agent.indexOf('firefox') > 0) {
            const regStr_ff = /firefox\/[\d.]+/gi;
            regArray = agent.match(regStr_ff);
        }
        else if (agent.indexOf('chrome') > 0) {
            const regStr_chrome = /chrome\/[\d.]+/gi;
            regArray = agent.match(regStr_chrome);
        }
        else if (agent.indexOf('safari') > 0 && agent.indexOf('chrome') < 0) {
            const regStr_saf = /safari\/[\d.]+/gi;
            regArray = agent.match(regStr_saf);
        }
        else {
            regArray = null;
        }
        return regArray ? regArray[0] : 'other';
    }
    /**
     * 获取设备操作系统版本
     */
    function getOSVersion() {
        let os = getOS();
        const nVer = navigator.appVersion;
        const nAgt = navigator.userAgent;
        let regArray;
        if (/Windows/.test(os)) {
            regArray = /Windows (.*)/.exec(nAgt);
            os = 'Windows';
        }
        switch (os) {
            case 'Mac OS':
            case 'Mac OS X':
                regArray = /Mac OS X ([._\d]+)/.exec(nAgt);
                break;
            case 'Android':
                regArray = /Android ([._\d]+)/.exec(nAgt);
                break;
            case 'iOS':
                regArray = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                return regArray
                    ? `${regArray[1]}.${regArray[2]}.${regArray[3] ? regArray[3] : 0}`
                    : 'other';
            default:
                regArray = null;
                break;
        }
        return regArray ? regArray[1] : 'other';
    }

    const DEDAULT_KEY = 'vue_track_key';
    const BASE_KEY = 'track_base_info';
    // 生成唯一id
    function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            const r = (Math.random() * 16) | 0;
            return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
        });
    }
    // 返回埋点基础信息
    function getBaseInfo() {
        const { width, height } = window.screen;
        const baseInfo = LocalStorage.get(BASE_KEY);
        const defaultInfo = {
            deviceId: generateUUID(),
            deviceBrand: getBrowserInfo(),
            deviceModel: navigator.userAgent,
            osName: getOS(),
            osVersion: getOSVersion(),
            screenWidth: width,
            screenHeight: height,
        };
        return Object.assign({}, defaultInfo, baseInfo);
    }
    // 返回埋点信息模板
    function getTemplateInfo() {
        return {
            eventId: '',
            eventTime: Date.now(),
            eventResource: '',
            eventModule: '',
            action: '',
        };
    }
    /**
     * 清除埋点信息
     * @param liftTime 当设置了埋点有效期时自动清除过期埋点
     */
    function clearStorage(defaultKey, liftTime) {
        if (liftTime) {
            const trackPoints = LocalStorage.get(defaultKey);
            const newTrackPoints = trackPoints.filter((item) => item.eventTime > liftTime);
            LocalStorage.set(defaultKey, newTrackPoints);
        }
        else {
            LocalStorage.remove(defaultKey);
        }
    }
    // 保存埋点信息到本地
    function write2Storage(defaultKey, trackInfo) {
        const trackPoints = LocalStorage.get(defaultKey) || [];
        trackPoints.push(Object.assign({}, trackInfo));
        LocalStorage.set(defaultKey, trackPoints);
    }
    /**
     * 修改埋点基础信息
     * @param baseKey 基础埋点信息对象或者对象里面的key
     * @param value 当key为key时对应的value
     */
    function setTrackBaseInfo(baseKey, value) {
        if (!baseKey)
            console.warn('缺少埋点基础信息');
        if (typeof baseKey !== 'string') {
            LocalStorage.set(BASE_KEY, value);
        }
        else {
            const baseInfo = LocalStorage.get(BASE_KEY) || {};
            baseInfo[baseKey] = value;
            LocalStorage.set(BASE_KEY, value);
        }
    }
    /**
     * 特殊情况手动埋点
     * @param options 回调函数
     * @param trackKey 时间间隔延迟多少毫秒
     */
    function manualBurying(options, trackKey) {
        const defaultKey = trackKey || LocalStorage.get(DEDAULT_KEY);
        const trackInfo = Object.assign({}, getTemplateInfo(), options);
        write2Storage(defaultKey, trackInfo);
    }
    /**
     * 节流
     * @param fn 回调函数
     * @param delay 时间间隔延迟多少毫秒
     */
    function throttle(fn, delay = 200, immediate = false) {
        let timer = null, remaining = 0, previous = Date.now();
        return function (...args) {
            const now = Date.now(), context = this;
            remaining = now - previous;
            if (remaining >= delay || immediate) {
                if (timer) {
                    clearTimeout(timer);
                }
                fn.apply(context, args);
                previous = now;
                immediate = false;
            }
            else {
                if (timer)
                    return;
                timer = setTimeout(() => {
                    fn.apply(context, args);
                    previous = Date.now();
                }, delay - remaining);
            }
        };
    }

    class TrackPoint {
        constructor(options = {}) {
            this.defaultKey = `${options.appId}_track`;
            this.intervalTime = options.time || 60 * 1000;
            this.getTrackConfig = options.getTrackConfig;
            this.getUploadId = options.getUploadId || (() => ({}));
            this.uploadTracks = options.uploadTracks;
            this.customActionFn = options.customActionFn || {};
            this.eventMap = {};
            this.trackList = [];
            this.baseInfo = {};
            this.userScrollDepth = 0; // 用户屏幕滚动的深度
            this.promiseQueue = []; // Promise缓存队列
            this.scrollCallback = null; // 监听滚动事件回调函数
            LocalStorage.set(DEDAULT_KEY, this.defaultKey);
            setTrackBaseInfo('appId', options.appId);
        }
        init() {
            // setInterval会把this指向window
            const fn = this.getPermission.bind(this);
            setInterval(fn, this.intervalTime);
        }
        // 缓存每一个绑定指令的Promise队列，队列为空则请求埋点配置接口
        getEventMapQueue() {
            return new Promise((resolve) => {
                if (this.promiseQueue.length === 0) {
                    this.getEventMap();
                }
                this.promiseQueue.push(resolve);
            });
        }
        // 请求埋点配置接口，请求成功执行所有缓存队列
        getEventMap() {
            return __awaiter(this, void 0, void 0, function* () {
                const resp = yield this.getTrackConfig();
                this.eventMap = resp;
                this.promiseQueue.forEach((resolve) => {
                    resolve();
                });
                this.promiseQueue = [];
            });
        }
        // 获取获取上传埋点的权限
        getPermission() {
            return __awaiter(this, void 0, void 0, function* () {
                const trackList = LocalStorage.get(this.defaultKey) || [];
                if (trackList.length === 0)
                    return;
                this.trackList = trackList;
                const { liftTime, uploadKey } = yield this.getUploadId();
                if (liftTime) {
                    clearStorage(this.defaultKey, +liftTime);
                }
                this.sendTrackInfo(uploadKey);
            });
        }
        /**
         * 上传本地埋点数据
         * @param uploadKey getPermission返回
         */
        sendTrackInfo(uploadKey) {
            return __awaiter(this, void 0, void 0, function* () {
                this.baseInfo = getBaseInfo();
                yield this.uploadTracks(this.trackList, this.baseInfo, uploadKey);
                clearStorage(this.defaultKey);
            });
        }
        // 组装当前埋点数据
        getTrackInfo(el, binding) {
            // eslint-disable-next-line prefer-const
            let { id, eventResource } = binding.value;
            const { track } = el.dataset;
            if (track)
                eventResource = track;
            // 埋点信息合并
            const trackInfo = Object.assign({}, getTemplateInfo(), this.eventMap[id] || {});
            trackInfo.eventResource = eventResource;
            return trackInfo;
        }
        // 埋点事件绑定
        handleBindEvent(el, binding) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!binding.value)
                    return;
                if (Object.keys(this.eventMap).length === 0) {
                    yield this.getEventMapQueue();
                }
                const { id } = binding.value;
                const { action } = this.eventMap[id] || {};
                const trackInfo = this.getTrackInfo(el, binding);
                if (action === 'click') {
                    this.addClickTrigger(el, trackInfo, action);
                }
                else if (action === 'scroll_up') {
                    this.addScrollTrigger(el, trackInfo);
                }
                else if (action === 'stay') {
                    this.addStayTrigger(trackInfo);
                }
                else if (this.customActionFn[action]) {
                    // 为保证自定义埋点的灵活性，采用回调函数进行
                    const cb = (info) => {
                        write2Storage(this.defaultKey, info);
                    };
                    this.customActionFn[action](trackInfo, cb);
                }
                else {
                    write2Storage(this.defaultKey, trackInfo);
                }
            });
        }
        // 添加点击、鼠标进过事件监听
        addClickTrigger(el, trackInfo, action) {
            const clickFn = () => {
                write2Storage(this.defaultKey, trackInfo);
            };
            el.addEventListener(action, throttle(clickFn, 100), false);
        }
        // 添加页面停留监听
        addStayTrigger(trackInfo) {
            LocalStorage.set('enter_time', Date.now());
            window.addEventListener('beforeunload', () => {
                const now = Date.now();
                trackInfo.stayTime = now - LocalStorage.get('enter_time');
                write2Storage(this.defaultKey, trackInfo);
            });
        }
        // 添加滚动事件监听
        addScrollTrigger(el, trackInfo) {
            const scrollFn = () => {
                const contentHeight = el.offsetHeight;
                const contentTop = el.getBoundingClientRect().top;
                const bodyClientHeight = document.documentElement.clientHeight;
                const scrollDepth = (((bodyClientHeight - contentTop) / contentHeight) *
                    100).toFixed(2);
                if (this.userScrollDepth < +scrollDepth) {
                    this.userScrollDepth = +scrollDepth;
                }
            };
            this.scrollCallback = throttle(scrollFn, 100);
            window.addEventListener('scroll', this.scrollCallback);
            window.addEventListener('beforeunload', () => {
                this.saveScrollTrack(trackInfo);
            });
        }
        // 保存滚动事件埋点数据
        saveScrollTrack(trackInfo) {
            trackInfo.scrollDepth = this.userScrollDepth;
            write2Storage(this.defaultKey, trackInfo);
            this.userScrollDepth = 0;
        }
        // 埋点事件取消绑定
        handleUnBindEvent(el, binding) {
            if (!binding.value)
                return;
            const { id } = binding.value;
            const { action } = this.eventMap[id] || {};
            if (['scroll_up', 'stay'].includes(action))
                return;
            const trackInfo = this.getTrackInfo(el, binding);
            if (action === 'stay') {
                write2Storage(this.defaultKey, trackInfo);
            }
            else {
                this.saveScrollTrack(trackInfo);
                window.removeEventListener('scroll', this.scrollCallback);
            }
        }
    }
    var index = {
        install(Vue, configs) {
            const Track = new TrackPoint(configs);
            Track.init();
            // 兼容vue 3.0
            const isVueNext = Vue.version.split('.')[0] === '3';
            const bindKey = isVueNext ? 'beforeMount' : 'bind';
            const unbindKey = isVueNext ? 'beforeUnmount' : 'unbind';
            Vue.directive('track', {
                [bindKey](el, binding) {
                    Track.handleBindEvent(el, binding);
                },
                [unbindKey](el, binding) {
                    Track.handleUnBindEvent(el, binding);
                },
            });
        },
    };

    exports.default = index;
    exports.manualBurying = manualBurying;
    exports.setTrackBaseInfo = setTrackBaseInfo;
    exports.throttle = throttle;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
